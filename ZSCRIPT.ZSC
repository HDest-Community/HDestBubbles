// vim: et sta
version "4.3"

class HDestBubbleHandler : StaticEventHandler
{
    HDestBubbler bubblers[MAXPLAYERS];
    Array<Class<HideousBubble> > bubbleClasses;

    Dictionary injectors;
    Dictionary injectorSprites;

    override void OnRegister()
    {
        injectors       = Dictionary.Create();
        injectorSprites = Dictionary.Create();

        for (int i = 0; i < AllActorClasses.Size(); i++)
        {
            let thisClass = AllActorClasses[i];

            // bubbles
            let bubbleClass = (Class<HideousBubble>)(thisClass);
            if (bubbleClass && !IsAbstract(bubbleClass)) bubbleClasses.Push(bubbleClass);
            if (bubbleClass) continue;

            // injectors
            let injectorMakerClass = (Class<HDInjectorMaker>)(thisClass);
            let injectorClass = injectorMakerClass? GetDefaultByType(injectorMakerClass).injectorType : (Class<Weapon>)(null);

            if (injectorClass)
            {
                let injectorName = injectorClass.GetClassName();
                let prevInjectorMaker = injectors.At(injectorName);
                let injectorMakerName = injectorMakerClass.GetClassName();
                if (hdb_debug && prevInjectorMaker != "")
                    console.printf("Redefined injector maker for injector '%s' as '%s' (was '%s')",
                        injectorName, prevInjectorMaker, injectorMakerName);

                injectors.Insert(injectorName, injectorMakerName);
            }

            if (injectorMakerClass) continue;
        }
    }

    // lzdoom compat: compare class against known abstract classes
    static clearscope bool IsAbstract(Class checkClass)
    {
        // return checkClass.isAbstract();
        return checkClass == 'HideousBubble' || checkClass == 'Bubble_Weapon';
    }

    override void WorldLoaded(WorldEvent e)
    {
        if (!e.IsSaveGame) return;

        HDestBubbler bubbler;
        let iter = ThinkerIterator.Create('HDestBubbler', Thinker.STAT_DEFAULT);
        while ((bubbler = HDestBubbler(iter.Next())))
        {
            if (CheckPlayer(bubbler.owner))
            {
                bubblers[bubbler.owner.PlayerNumber()] = bubbler;
                bubbler.handler = self;
            }
            else bubbler.Destroy();
        }
    }

    override void WorldUnloaded(WorldEvent e)
    {
        for (int i = 0; i < bubblers.Size(); i++)
            if (bubblers[i]) bubblers[i].Destroy();
    }

    override void WorldTick()
    {
        bool enabled = hdb_enabled;

        // don't save bubble thinkers
        // this doesn't work if the game's saved while paused
        if (gameaction == ga_savegame || gameaction == ga_autosave) enabled = false;

        if (!enabled) uiCtx.saving = false;

        for (int pi = 0; pi < bubblers.Size(); pi++)
        {
            let shouldHaveThinker = CheckPlayer(players[pi].mo) && enabled;
            if (shouldHaveThinker != !!bubblers[pi])
            {
                if (shouldHaveThinker)
                {
                    bubblers[pi] = new('HDestBubbler');
                    bubblers[pi].owner = players[pi].mo;
                    bubblers[pi].handler = self;
                }
                else bubblers[pi].Destroy();
            }
        }
    }

    override void NetworkProcess(ConsoleEvent e)
    {
        if (e.Name ~== "hdb_cleanup")
        {
            for (int i = 0; i < bubblers.Size(); i++)
                if (bubblers[i]) bubblers[i].Destroy();

            uiCtx.saving = false;
        }
    }

    HDestBubblesUIStorage uiCtx;
    override void UITick()
    {
        if (uiCtx.saving)
        {
            uiCtx.saving = false;

            let iter = ThinkerIterator.Create('HDestBubbler', Thinker.STAT_DEFAULT);
            if (!iter.Next()) return;

            console.printf("\n"
                "\ciWARNING\cj: Failed to destroy bubble thinkers before save.\n"
                "\cjYou will not be able to load this save without Hideous Action Bubbles.\n"
                "\cjTo fix this, \cddisable bubbles while unpaused\cj or run '\cdhdb_cleanup\cj', then save again.\n\n"
            );
        }
        else if (gameaction == ga_savegame || gameaction == ga_autosave) uiCtx.saving = true;
    }

    static clearscope bool CheckPlayer(PlayerPawn mo)
    {
        return mo && mo.player && HDPlayerPawn(mo) && mo.health > 0;
    }

    static clearscope HDestBubbleHandler Get() { return HDestBubbleHandler(StaticEventHandler.Find('HDestBubbleHandler')); }
}

struct HDestBubblesUIStorage { bool saving; }

class HideousBubble : Actor abstract
{
    Vector3 home;
    double shift;
    double lower;
    double reach;
    double pitch_offset;
    bool pitch_affected;
    bool visible;
    property shift:shift;
    property lower:lower;
    property reach:reach;
    property pitch_affected:pitch_affected;
    property pitch_offset:pitch_offset;

    HDestBubbler bubbler;

    double map(double v, double min_a, double max_a, double min_b, double max_b)
    {
        return (v - min_a) / (max_a - min_a) * (max_b - min_b) + min_b;
    }

    virtual void MoveHome()
    {
        Vector3 offset;
        if (pitch_affected)
        {
            double tp = min(75., target.pitch + pitch_offset);
            offset = (AngleToVector(target.angle, abs(cos(tp))), -sin(tp)) * reach;
        }
        else
        {
            offset = (AngleToVector(target.angle), 0) * reach;
        }
        offset += AngleToVector(target.angle - 90., shift);
        home = (target.pos.xy, target.player.viewz - lower) + offset;
        SetOrigin(home, true);
    }

    virtual bool CheckVisible(Actor target) const { return true; }

    override void Tick()
    {
        if (isFrozen() || !HDestBubbleHandler.CheckPlayer(PlayerPawn(target))) return;

        if (CheckVisible(target) != visible) SetVisible(!visible);
        if (bDestroyed) return;

        if (visible && GetRenderStyle() != target.GetRenderStyle())
            A_SetRenderStyle(target.alpha, target.GetRenderStyle());

        if (visible && tics != -1 && --tics <= 0 && !SetState(CurState.NextState)) return;

        MoveHome();
    }

    virtual void SetVisible(bool setting)
    {
        A_SetRenderStyle(target.alpha, setting? target.GetRenderStyle() : STYLE_None);
        visible = setting;
    }

    void CopyInterpolation()
    {
        ClearInterpolation();
        prev = pos + target.prev - target.pos;
    }

    String CopyWeaponSprite(HDWeapon weapon, string fallbackSprite, bool useSpriteScale = false)
    {
        string sprite_name; double sprite_scale;
        [sprite_name, sprite_scale] = weapon.GetPickupSprite();

        if (sprite_name == "") sprite_name = fallbackSprite;
        if (!sprite_scale) useSpriteScale = false;

        CopySprite(sprite_name, useSpriteScale? (1, 1) * sprite_scale : (weapon.scale.x, weapon.scale.y));

        return sprite_name;
    }

    string warned_sprite;
    void CopySprite(string sprite_name, vector2 sprite_scale = (1, 1))
    {
        if (!hdb_debug) warned_sprite = "";

        if (!IsValidSprite(sprite_name))
        {
            if (hdb_debug && sprite_name != warned_sprite)
            {
                console.printf("Tried to use invalid sprite '%s'", sprite_name);
                warned_sprite = sprite_name;
            }

            sprite = Sprite_TNT1;
            return;
        }
        else if (hdb_debug && !IsSprite(sprite_name) && sprite_name != warned_sprite)
        {
            console.printf("Tried to use invalid sprite '%s', but found valid sprite '%s'", sprite_name, sprite_name.Left(4));
            warned_sprite = sprite_name;
        }

        sprite = GetSpriteIndex(sprite_name);
        scale = Vec2Mul(default.scale, sprite_scale);
        frame = IsSprite(sprite_name)? sprite_name.ByteAt(4) - 65 : 0;
    }

    static clearscope vector2 Vec2Mul(vector2 a, vector2 b) { return (a.x * b.x, a.y * b.y); }

    // check if sprite exists - does not verify if the sprite is registered
    static clearscope bool IsSprite(String sprite_name)
    {
        // check for sprites ONLY - with default flags this falls back to any texture
        return TexMan.CheckForTexture(sprite_name, TexMan.Type_Sprite, 0).IsValid();
    }

    // check if sprite is valid and safe to use
    static bool IsValidSprite(String sprite_name) { return GetSpriteIndex(sprite_name) >= 0; }

    void LowerIfAttackHeld(double newReach, double newLower)
    {
        let attack = target.player.cmd.buttons & BT_ATTACK;

        let dreach = (attack? newReach : default.reach) - reach;
        let dlower = (attack? newLower : default.lower) - lower;

        if (!(dreach ~== 0)) reach += dreach * 0.5;
        if (!(dlower ~== 0)) lower += dlower * 0.5;
    }

    // TNT1 is always the first sprite
    const Sprite_TNT1 = 0;

    default
    {
        +FORCEXYBILLBOARD
        +NOINTERACTION
        +NOBLOCKMAP
        +NOGRAVITY
        HideousBubble.shift 0.;
        HideousBubble.lower 0.;
        HideousBubble.reach 21.;
        HideousBubble.pitch_affected true;
        HideousBubble.pitch_offset 30.;
        FloatBobPhase 0;
        RenderStyle "None";
        Height 1.;
        Radius 0.5;
    }

    states
    {
    Spawn:
        SKUL A -1;
        Stop;
    }
}

class Bubble_Weapon : HideousBubble abstract
{
    string weaponClass; property weaponClass: weaponClass;
    string copyScale;   property copyScale:   copyScale;

    default
    {
        Bubble_Weapon.copyScale "Weapon";
        RenderStyle "Normal";
    }

    override void BeginPlay()
    {
        visible = true;

        class<Actor> cls = copyScale;
        if (cls == 'Weapon') cls = weaponClass;
        if (cls) scale = Vec2Mul(default.scale, GetDefaultByType(cls).scale);
    }

    override bool CheckVisible(Actor target) { return target.player.ReadyWeapon is weaponClass; }

    override void SetVisible(bool setting)
    {
        if (!setting)
        {
            Destroy();
            bubbler.MakeWeaponBubble();
        }
        else super.SetVisible(setting);
    }
}

class Bubble_HDMedikitter : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "HDMedikitter";
    }

    states
    {
    Spawn:
        MEDI # 1
        {
            let hdmk = HDMedikitter(target.player.readyweapon);
            frame = (hdmk.weaponstatus[2] < 0)? 1 : 2;

            LowerIfAttackHeld(7., 7.);
        }
        Wait;
    }
}

class Bubble_MagManager : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "MagManager";
        HideousBubble.pitch_offset 0.;
        HideousBubble.lower 12.;
    }

    override bool CheckVisible(Actor target)
    {
        if (!super.CheckVisible(target)) return false;

        let thisMag = HDMagAmmo(MagManager(target.player.readyweapon).thismag);
        return thisMag && thisMag.mags.Size() > 0;
    }

    states
    {
    Spawn:
        TNT1 A 1
        {
            let mag = HDMagAmmo(MagManager(target.player.readyweapon).thismag);
            int curmag = mag.mags[mag.mags.size() - 1];

            string magsprite; string roundsprite; name roundtype; double scl;
            [magsprite, roundsprite, roundtype, scl] = mag.getmagsprite(curmag);
            CopySprite(magsprite);

            if (hdb_magstyle >= 0) scale = mag.scale;

            if (!IsSprite(magsprite)) frame = curmag == 0;
        }
        Wait;
    }
}

class Bubble_HDBackpack : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "HDBackpack";
        HideousBubble.lower 16.;
    }

    double GetSpriteHeight(String sprite)
    {
        let tex  = TexMan.CheckForTexture(sprite, TexMan.Type_Sprite, 0);
        let size = TexMan.GetScaledSize(tex);
        return size.y;
    }

    states
    {
    Spawn:
        BPAK A 1
        {
            angle = target.angle + 180.;

            let backpack = HDBackpack(target.player.ReadyWeapon);
            CopyWeaponSprite(backpack, "BPAK");

            let defBackpack = GetDefaultByType('HDBackpack');
            let baseHeight = GetSpriteHeight(defBackpack.GetPickupSprite()) * defBackpack.scale.y;
            let thisHeight = GetSpriteHeight(backpack.GetPickupSprite())    * backpack.scale.y;

            let prevLower = lower;
            lower = default.lower - (baseHeight - thisHeight);

            prev.z += prevLower - lower;

            scale = backpack.scale;
        }
        Wait;
    }
}

class Bubble_WornBackpack : HideousBubble
{
    override bool CheckVisible(Actor target)
    {
        let backpack = target.FindInventory('HDBackpack');
        return backpack && backpack != target.player.ReadyWeapon && hdb_wornbackpacks;
    }

    default
    {
        -FORCEXYBILLBOARD
        HideousBubble.lower 24.;
        HideousBubble.reach -16.;
        HideousBubble.pitch_affected false;
    }

    states
    {
    Spawn:
        BPAK A 1 { angle = target.angle + 180.; }
        Wait;
    }
}

class Bubble_WornWIMPBackpack : Bubble_WornBackpack
{
    string className;       property className: className;
    class<Inventory> cls;   property cls:       cls;

    override void BeginPlay()
    {
        Super.BeginPlay();
        className = "WIMPHDBackpack";
        cls = className;
    }

    override bool CheckVisible(Actor target)
    {
        if (cls)
        {
            let backpack = target.FindInventory(cls);
            return backpack && !(target.player.ReadyWeapon is "HDBackpack") && hdb_wornbackpacks;
        }

        return false;
    }
}

class Bubble_DERPUsable : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "DERPUsable";
    }

    states
    {
    Spawn:
        DERP A 1
        {
            angle = target.angle;
            translation = target.translation;
        }
        Wait;
    }
}

class Bubble_HERPUsable : Bubble_DERPUsable
{
    default
    {
        Bubble_Weapon.weaponClass "HERPUsable";
        HideousBubble.lower 12.;
    }

    states
    {
    Spawn:
        HERP A 1
        {
            angle = target.angle;
            translation = target.translation;
            frame = (target.player.cmd.buttons & BT_ZOOM) && (target.player.cmd.buttons & BT_ATTACK);
        }
        Wait;
    }
}

class Bubble_Injector : Bubble_Weapon
{
    static clearscope Class<HDInjectorMaker> GetInjectorMaker(Weapon injector)
    {
        return HDestBubbleHandler.Get().injectors.At(injector.GetClassName());
    }

    static clearscope int GetInjectorSprite(Actor injectorMaker)
    {
        let spriteMap    = HDestBubbleHandler.Get().injectorSprites;
        let spriteMapKey = injectorMaker.GetClassName();
        let spriteString = spriteMap.At(spriteMapKey);
        if (spriteString == "")
        {
            Array<State> seenStates;
            for (State st = injectorMaker.spawnState;
                st && seenStates.Find(st) == seenStates.Size();
                st = st.NextState)
            {
                seenStates.Push(st);

                if (st.sprite > 0)
                {
                    spriteMap.Insert(spriteMapKey, "" .. st.sprite);
                    return st.sprite;
                }
            }
        }

        return spriteString.ToInt();
    }

    override bool CheckVisible(Actor target)
    {
        let wep = HDWeapon(target.player.ReadyWeapon);
        return wep? !!GetInjectorMaker(wep) : false;
    }

    states
    {
    Spawn:
        TNT1 A 1
        {
            let injectorMakerClass = GetInjectorMaker(target.player.ReadyWeapon);
            let injectorMaker      = target.FindInventory(injectorMakerClass);

            if (injectorMaker)
            {
                sprite = GetInjectorSprite(injectorMaker);
                scale  = injectorMaker.scale;
            }
            else sprite = Sprite_TNT1;

            LowerIfAttackHeld(7., 7.);
        }
        Wait;
    }
}

class Bubble_HDHealingBottler : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "HDHealingBottler";
        Bubble_Weapon.copyScale   "HDHealingPotion";
    }

    states
    {
    Spawn:
        BON1 A 1
        {
            LowerIfAttackHeld(7., 3.);
        }
        Wait;
    }
}

class Bubble_HDGrenadeThrower : Bubble_Weapon
{
    default
    {
        Bubble_Weapon.weaponClass "HDGrenadeThrower";
    }

    states
    {
    Spawn:
        FRAG A 1
        {
            let grenade = HDGrenadeThrower(target.player.ReadyWeapon);
            if (target.FindInventory(grenade.grenadeammotype)
                || (grenade.weaponstatus[0] & FRAGF_INHAND))
            {
                CopyWeaponSprite(grenade, "FRAG");

                scale = GetDefaultByType(grenade.grenadeammotype).scale;
            }
            else sprite = Sprite_TNT1;
        }
        Wait;
    }
}

class Bubble_PlayerHeading : HideousBubble
{
    override void PostBeginPlay()
    {
        pitch = 90.;
    }

    override bool CheckVisible(Actor target) { return target != players[consoleplayer].camera && hdb_headings; }

    default
    {
        +INTERPOLATEANGLES
        -FORCEXYBILLBOARD
        +FLATSPRITE
        +ROLLSPRITE
        HideousBubble.reach 1.;
    }

    states
    {
    Spawn:
        HDTR Z 1
        {
            angle = target.angle + 90.;
            roll = target.pitch;
        }
        Wait;
    }
}

class Bubble_ReadyWeapon : HideousBubble
{
    override void PostBeginPlay()
    {
        pitch = -90.;
    }

    override bool CheckVisible(Actor target)
    {
        if (bubbler.weaponBubble) return false;

        let wep = HDWeapon(target.player.ReadyWeapon);
        if (!wep || wep is 'HDWoundFixer') return false;

        let sprite = wep.GetPickupSprite();
        if (sprite == "" || sprite == "TNT1") return false;

        return hdb_visibletoself && hdb_weapons;
    }

    Weapon prevWeapon;
    override void MoveHome()
    {
        super.MoveHome();
        if (!visible) return;

        let weapon = target.player.ReadyWeapon;
        if (prevWeapon != (prevWeapon = weapon)) CopyInterpolation();
    }

    default
    {
        +INTERPOLATEANGLES
        -FORCEXYBILLBOARD
        +FLATSPRITE
        +ROLLSPRITE

        HideousBubble.shift 1.;
        HideousBubble.pitch_offset 0.;
    }

    states
    {
    Spawn:
        TNT1 A 1
        {
            let rw = hdweapon(target.player.readyweapon);
            let hdp = hdplayerpawn(target);
            let cam = hdp.scopecamera? hdp.scopecamera : target;

            angle = cam.angle - 90. + hdp.wepbob.x * 0.1;
            roll  = cam.pitch;
            lower = hdp.wepbob.y * 0.1;

            let sprite_name = CopyWeaponSprite(rw, "TNT1");

            textureid tex = TexMan.CheckForTexture(sprite_name, TexMan.TYPE_SPRITE);
            vector2 toff  = TexMan.GetScaledOffset(tex);
            vector2 tsize = TexMan.GetScaledSize(tex);

            lower += tsize.y * .7;

            reach = HDSMG(rw)? 8. : 16.;

            if (HDSMG(rw) || ThunderBuster(rw))
                lower += 2.;
        }
        Wait;
    }
}

class HDestBubbler : Thinker
{
    HideousBubble weaponBubble;
    Array<HideousBubble> bubbles;

    HDestBubbleHandler handler;
    PlayerPawn owner;

    override void OnDestroy()
    {
        bubbles.Push(weaponBubble);

        for (int i = 0; i < bubbles.size(); i++)
            if (bubbles[i]) bubbles[i].Destroy();
    }

    HideousBubble MakeBubble(Class<HideousBubble> bubbleClass)
    {
        let bubble = HideousBubble(Actor.Spawn(bubbleClass));
        if (bubble)
        {
            bubble.target = owner;
            bubble.bubbler = self;
            bubble.MoveHome();
            bubble.CopyInterpolation();
        }

        return bubble;
    }

    bool CheckBubble(Class<HideousBubble> bubbleClass) const
    {
        let defaultBubble = GetDefaultByType(bubbleClass);
        return defaultBubble.CheckVisible(owner);
    }

    void MakeWeaponBubble()
    {
        for (int i = handler.bubbleClasses.Size() - 1; i >= 0; i--)
        {
            let bubbleClass = (Class<Bubble_Weapon>)(handler.bubbleClasses[i]);
            if (!bubbleClass || !CheckBubble(bubbleClass)) continue;

            weaponBubble = MakeBubble(bubbleClass);
            return;
        }
    }

    override void Tick()
    {
        if (!HDestBubbleHandler.CheckPlayer(owner)) { Destroy(); return; }
        if (!weaponBubble) MakeWeaponBubble();
    }

    override void PostBeginPlay()
    {
        for (int i = 0; i < handler.bubbleClasses.Size(); i++)
        {
            let bubbleClass = (Class<HideousBubble>)(handler.bubbleClasses[i]);
            if (bubbleClass) bubbles.Push(MakeBubble(bubbleClass));
        }
    }
}
